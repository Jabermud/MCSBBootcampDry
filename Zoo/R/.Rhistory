knitr::opts_chunk$set(echo = TRUE)
## Read in RDS file with Single-Cell Data
```{r read in data}
####NOTE: You will need to change the file path based on where you saved these files.
#extract metadata (information about each cell, e.g. cluster assignment)
cell_metadata <- read.table("C:\MCSBBootcampDry\Zoo\R\cell_metadata.txt")
#extract the normalized data matrix
expression_matrix <- readRDS("C:\MCSBBootcampDry\Zoo\R\expression_matrix.rds")
```{r read in data}
```{r read in data}
#extract metadata (information about each cell, e.g. cluster assignment)
cell_metadata <- read.table("C:/MCSBBootcampDry/Zoo/R/cell_metadata.txt")
#check dimensions of the expression matrix (rows are genes, columns are cells)
dim(expression_matrix) #17,779 genes across 1986 cells
#check dimensions of the expression matrix (rows are genes, columns are cells)
dim(expression_matrix) #17,779 genes across 1986 cells
#extract the normalized data matrix
expression_matrix <- readRDS("C:/MCSBBootcampDry/Zoo/R/expression_matrix.rds")
#check dimensions of the expression matrix (rows are genes, columns are cells)
dim(expression_matrix) #17,779 genes across 1986 cells
expression_matrix[1:5,1:5]
#check metadata column content
head(cell_metadata)
#check metadata column content
head(cell_metadata)
#simple count for number of occurances of WT and Treated
table(cell_metadata$orig.ident)
#simple count for number of occurances of WT and Treated
table(cell_metadata$)
orig.ident
#simple count for number of occurances of WT and Treated
table(cell_metadata$orig.ident)
#rows of the table are each condition, columns are the cluster
table(cell_metadata$orig.ident, cell_metadata$res.0.4)
#first item is the dataframe (a type of R object containing a mix of numbers, characters and factors) that has the data you want to plot
#next, you give a mapping, where x=column name of data you want to plot on the x-axis, etc with fill generating a different color for each factor you plot
#finally, you tell ggplot the type of plot you want to render (for example, geom_point() would make a dot plot)
ggplot(cell_metadata, mapping=aes(x=orig.ident, y=nGene, fill=orig.ident)) + geom_violin()
library(dplyr)
library(tidyr)
library(ggplot2)
library(pheatmap)
#first item is the dataframe (a type of R object containing a mix of numbers, characters and factors) that has the data you want to plot
#next, you give a mapping, where x=column name of data you want to plot on the x-axis, etc with fill generating a different color for each factor you plot
#finally, you tell ggplot the type of plot you want to render (for example, geom_point() would make a dot plot)
ggplot(cell_metadata, mapping=aes(x=orig.ident, y=nGene, fill=orig.ident)) + geom_violin()
#first item is the dataframe (a type of R object containing a mix of numbers, characters and factors) that has the data you want to plot
#next, you give a mapping, where x=column name of data you want to plot on the x-axis, etc with fill generating a different color for each factor you plot
#finally, you tell ggplot the type of plot you want to render (for example, geom_point() would make a dot plot)
ggplot(cell_metadata, mapping=aes(x=orig.ident, y=nGene, fill=orig.ident)) + geom_violin()+geom_jitter()
#this technically sums a true/false matrix where true = 1 and false = 0
n_cells_expressed <- rowSums(expression_matrix > 0)
#this technically sums a true/false matrix where true = 1 and false = 0
n_cells_expressed <- rowSums(expression_matrix > 0)
#which selects values from the first vector that match values in the second vector
most_expressed <- n_cells_expressed[which(n_cells_expressed %in% max(n_cells_expressed))]
n_cells_expressed <- rowSums(expression_matrix > 0)
#this technically sums a true/false matrix where true = 1 and false = 0
n_cells_expressed <- rowSums(expression_matrix > 0)
head
n_cells_expressed
most_expressed
names_of_most_expressed
#to keep only the gene names, we can use names()
names_of_most_expressed <- names(most_expressed)
names_of_most_expressed
#generate expression matrix with only the genes from above
gene_subset <- expression_matrix[names_of_most_expressed,]
gene_subset
total_expression <- rowSums(gene_subset)
sorted_expression <- sort(total_expression, decreasing = T)
total_expression
sorted_expression
plot(sorted_expression)
#Step 1: Extract MKI67 & format as a data frame
#NOTE: If expression_matrix is denoted as a data.frame, this will have improper dimensions for downstream steps
#R is overly tolerant of variable types in the sense that it will not throw an error but it will give absurd results
#Therefore, we ensure expression_matrix is a matrix by wrapping it in the data type altering as.matrix()
MKI67_df <- as.matrix(expression_matrix)["MKI67",]
MKI67_expression <- data.frame(MKI67 = MKI67_df)
MKI67_df
MKI67_expression
#Step 2: Reorder data frame to match ordering of metadata
MKI67_expression <- MKI67_expression[rownames(cell_metadata),]
MKI67_expression
#Step 3: Once we are sure that our dataset are in the same order, we can add a column of MKI67 expresison to our cell metadata taking advantage of the $ operator for column references.
cell_metadata$MKI67_expression <- MKI67_expression
cell_metadata$MKI67_expression
#Step 1: Extract MKI67 & format as a data frame
#NOTE: If expression_matrix is denoted as a data.frame, this will have improper dimensions for downstream steps
#R is overly tolerant of variable types in the sense that it will not throw an error but it will give absurd results
#Therefore, we ensure expression_matrix is a matrix by wrapping it in the data type altering as.matrix()
MKI67_df <- as.matrix(expression_matrix)["MKI67",]
MKI67_expression <- data.frame(MKI67 = MKI67_df)
MKI67_expression
#Step 2: Reorder data frame to match ordering of metadata
MKI67_expression <- MKI67_expression[rownames(cell_metadata),]
MKI67_expression
#Step 3: Once we are sure that our dataset are in the same order, we can add a column of MKI67 expresison to our cell metadata taking advantage of the $ operator for column references.
cell_metadata$MKI67_expression <- MKI67_expression
cell_metadata$MKI67_expression
MKI67_expression <- MKI67_expression[rownames(cell_metadata),]
#Step 2: Reorder data frame to match ordering of metadata
MKI67_expression <- MKI67_expression[rownames(cell_metadata),]
MKI67_expression <- data.frame(MKI67 = MKI67_df)
MKI67_expression
#Step 2: Reorder data frame to match ordering of metadata
MKI67_expression <- MKI67_expression[rownames(cell_metadata),]
MKI67_expression <- MKI67_expression[rownames(cell_metadata),]
#Step 2: Reorder data frame to match ordering of metadata
MKI67_expression <- MKI67_expression[rownames(cell_metadata),]
#Step 3: Once we are sure that our dataset are in the same order, we can add a column of MKI67 expresison to our cell metadata taking advantage of the $ operator for column references.
cell_metadata$MKI67_expression <- MKI67_expression
cell_metadata$MKI67_expression <- MKI67_expression
cell_metadata$MKI67_expression <- MKI67_expression
cell_metadata$MKI67_expression
#Step 4: Finally, we can compute the correlation
correlation_mki67 <- cor(cell_metadata$G2M.Score, cell_metadata$MKI67_expression)
correlation_mki67
WT_subset <- subset(cell_metadata, orig.ident == "WT")
WT_subset
correlation_mki67_WT <- cor(WT_subset$G2M.Score, WT_subset$MKI67_expression)
correlation_mki67_WT
average_mki67_by_cluster_and_condition <- cell_metadata %>%
group_by(res.0.4, orig.ident) %>%
summarise(mean_mki67 = mean(MKI67_expression))
#first, we list the data frame we need to work from, in this case, cell_metadata
#%>% syntax will take the data output from the previous step and perform the task listed after the arrow on that data
#we group our data frame first by the cluster, and next by condition
#finally, we summarize our data for each group by taking the average of MKI67
average_mki67_by_cluster_and_condition <- cell_metadata %>%
group_by(res.0.4, orig.ident) %>%
summarise(mean_mki67 = mean(MKI67_expression))
summarise(mean_mki67 = mean(MKI67_expression)
ggplot(average_mki67_by_cluster_and_condition, mapping = aes(x=res.0.4, y=mean_mki67, fill=orig.ident)) + geom_bar(stat="identity", position="dodge")
summarise
#first, we list the data frame we need to work from, in this case, cell_metadata
#%>% syntax will take the data output from the previous step and perform the task listed after the arrow on that data
#we group our data frame first by the cluster, and next by condition
#finally, we summarize our data for each group by taking the average of MKI67
average_mki67_by_cluster_and_condition <- cell_metadata %>%
group_by(res.0.4, orig.ident) %>%
summarise(mean_mki67 = mean(MKI67_expression))
average_mki67_by_cluster_and_condition
average_mki67_by_cluster_and_condition
summarise
summarise(mean_mki67 = mean(MKI67_expression)
ggplot(average_mki67_by_cluster_and_condition, mapping = aes(x=res.0.4, y=mean_mki67, fill=orig.ident)) + geom_bar(stat="identity", position="dodge")
mki67_sub <- subset(cell_metadata,MKI67_expression > 0)
average_mki67_by_cluster_and_condition_sub <- mki67_sub %>%
group_by(res.0.4, orig.ident) %>%
summarise(mean_mki67 = mean(MKI67_expression))
ggplot(average_mki67_by_cluster_and_condition_sub, mapping = aes(x=res.0.4, y=mean_mki67, fill=orig.ident)) + geom_bar(stat="identity", position="dodge")
mki67_sub <- subset(cell_metadata,MKI67_expression > 0)
average_mki67_by_cluster_and_condition_sub <- mki67_sub %>%
group_by(res.0.4, orig.ident) %>%
summarise(mean_mki67 = mean(MKI67_expression))
ggplot(average_mki67_by_cluster_and_condition_sub, mapping = aes(x=res.0.4, y=mean_mki67, fill=orig.ident)) + geom_bar(stat="identity", position="dodge")
ggplot(average_mki67_by_cluster_and_condition_sub, mapping = aes(x=res.0.4, y=mean_mki67, fill=orig.ident)) + geom_bar(stat="identity", position="dodge")
#first, we list the data frame we need to work from, in this case, cell_metadata
#%>% syntax will take the data output from the previous step and perform the task listed after the arrow on that data
#we group our data frame first by the cluster, and next by condition
#finally, we summarize our data for each group by taking the average of MKI67
average_mki67_by_cluster_and_condition <- cell_metadata %>%
group_by(res.0.4, orig.ident) %>%
summarise(mean_mki67 = mean(MKI67_expression))
ggplot(average_mki67_by_cluster_and_condition, mapping = aes(x=res.0.4, y=mean_mki67, fill=orig.ident)) + geom_bar(stat="identity", position="dodge")
mki67_sub <- subset(cell_metadata,MKI67_expression > 0)
average_mki67_by_cluster_and_condition_sub <- mki67_sub %>%
group_by(res.0.4, orig.ident) %>%
summarise(mean_mki67 = mean(MKI67_expression))
ggplot(average_mki67_by_cluster_and_condition_sub, mapping = aes(x=res.0.4, y=mean_mki67, fill=orig.ident)) + geom_bar(stat="identity", position="dodge")
ggplot(average_mki67_by_cluster_and_condition_sub, mapping = aes(x=res.0.4, y=mean_mki67, fill=orig.ident)) + geom_bar(stat="identity", position="dodge")
ggplot(average_mki67_by_cluster_and_condition_sub, mapping = aes(x=res.0.4, y=mean_mki67, fill=orig.ident)) + geom_bar(stat="identity", position="dodge")
average_mki67_by_cluster_and_condition_sub_2 <- mki67_sub %>%
group_by(res.0.4, orig.ident) %>%
filter(MKI67_expression > 0) %>%
summarise(mean_mki67 = mean(MKI67_expression))
ggplot(average_mki67_by_cluster_and_condition_sub_2, mapping = aes(x=res.0.4, y=mean_mki67, fill=orig.ident)) + geom_bar(stat="identity", position="dodge")
genes_of_interest <- c("KRT14","KRT18","ANKRD30A","SLPI","GAPDH")
genes_of_interest
#to plot these genes in the way requested, we will need to make a new data frame similar to our previous one with MKI67. This example shows some of the weird tricks you have to use in R to get things working across data objects.
genes_of_interest_df <- expression_matrix[genes_of_interest,rownames(cell_metadata)]
matrix_subset_of_interest <- as.matrix(t(genes_of_interest_df))
genes_of_interest_df
matrix_subset_of_interest
#since we have multiple columns to add to the metadata, we will want to
genes_of_interest_with_necessary_metadata <- merge(cell_metadata[,c("res.0.4","orig.ident")], as.data.frame(matrix_subset_of_interest), by="row.names")
genes_of_interest_with_necessary_metadata <- merge(cell_metadata[,c("res.0.4","orig.ident")], as.data.frame(matrix_subset_of_interest), by="row.names")
rownames(genes_of_interest_with_necessary_metadata) <- genes_of_interest_with_necessary_metadata$Row.names
genes_of_interest_with_necessary_metadata
#to plot these genes in the way requested, we will need to make a new data frame similar to our previous one with MKI67. This example shows some of the weird tricks you have to use in R to get things working across data objects.
genes_of_interest_df <- expression_matrix[genes_of_interest,rownames(cell_metadata)]
#since we have multiple columns to add to the metadata, we will want to
genes_of_interest_with_necessary_metadata <- merge(cell_metadata[,c("res.0.4","orig.ident")], as.data.frame(matrix_subset_of_interest), by="row.names")
rownames(genes_of_interest_with_necessary_metadata) <- genes_of_interest_with_necessary_metadata$Row.names
head(genes_of_interest_with_necessary_metadata)
genes_melt <- genes_of_interest_with_necessary_metadata %>%
group_by(res.0.4, orig.ident) %>%
gather(key="gene",value="expression", KRT14:GAPDH)
genes_melt <- genes_of_interest_with_necessary_metadata %>%
group_by(res.0.4, orig.ident) %>%
gather(key="gene",value="expression", KRT14:GAPDH)
head(genes_of_interest_with_necessary_metadata)
colnames(genes_melt) <- c("cluster","condition","gene","expression")
colnames(genes_melt) <- c("cluster","condition","gene","expression")
head(genes_melt)
ggplot(genes_melt, mapping = aes(x=gene, y=expression, fill=factor(condition))) + geom_bar(stat="identity",position="dodge") + facet_grid(.~cluster) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
ggplot
ggplot(genes_melt, mapping = aes(x=gene, y=expression, fill=factor(condition))) + geom_bar(stat="identity",position="dodge") + facet_grid(.~cluster)
ggplot(genes_melt, mapping = aes(x=gene, y=expression, fill=factor(condition))) + geom_bar(stat="identity",position="dodge") + facet_grid(.~cluster)
###Question 11: Generate a heatmap and annotate the clusters/condition for each cell in this heatmap.
```{r q11}
genes_of_interest <- c("KRT14","KRT18","ANKRD30A","SLPI","GAPDH")
ggplot(genes_melt, mapping = aes(x=gene, y=expression, fill=factor(condition))) + geom_bar(stat="identity",position="dodge") + facet_grid(.~cluster) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
ggplot(genes_melt, mapping = aes(x=gene, y=expression, fill=factor(condition))) + geom_bar(stat="identity",position="dodge") + facet_grid(.~cluster) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
ggplot(genes_melt, mapping = aes(x=gene, y=expression, fill=factor(condition))) + geom_bar(stat="identity",position="dodge") + facet_grid(.~cluster) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
colnames(genes_melt) <- c("cluster","condition","gene","expression")
#now, we want to reformat this data to generate a list of gene names instead of having each gene with its own column (since we need a single column for the x-axis to be each gene)
genes_melt <- genes_of_interest_with_necessary_metadata %>%
group_by(res.0.4, orig.ident) %>%
gather(key="gene",value="expression", KRT14:GAPDH)
genes_of_interest <- c("KRT14","KRT18","ANKRD30A","SLPI","GAPDH")
#to plot these genes in the way requested, we will need to make a new data frame similar to our previous one with MKI67. This example shows some of the weird tricks you have to use in R to get things working across data objects.
genes_of_interest_df <- expression_matrix[genes_of_interest,rownames(cell_metadata)]
matrix_subset_of_interest <- as.matrix(t(genes_of_interest_df))
#since we have multiple columns to add to the metadata, we will want to
genes_of_interest_with_necessary_metadata <- merge(cell_metadata[,c("res.0.4","orig.ident")], as.data.frame(matrix_subset_of_interest), by="row.names")
rownames(genes_of_interest_with_necessary_metadata) <- genes_of_interest_with_necessary_metadata$Row.names
#remove the column Row.Names which exists in the first position of the data frame
genes_of_interest_with_necessary_metadata <- genes_of_interest_with_necessary_metadata[,-1]
#now, we want to reformat this data to generate a list of gene names instead of having each gene with its own column (since we need a single column for the x-axis to be each gene)
genes_melt <- genes_of_interest_with_necessary_metadata %>%
group_by(res.0.4, orig.ident) %>%
gather(key="gene",value="expression", KRT14:GAPDH)
colnames(genes_melt) <- c("cluster","condition","gene","expression")
ggplot(genes_melt, mapping = aes(x=gene, y=expression, fill=factor(condition))) + geom_bar(stat="identity",position="dodge") + facet_grid(.~cluster) + theme(axis.text.x = element_text(angle = 90, hjust = 1))
genes_of_interest <- c("KRT14","KRT18","ANKRD30A","SLPI","GAPDH")
pheatmap(expression_matrix[genes_of_interest,],
annotation_col= cell_metadata[,c("res.0.4","orig.ident")],
show_colnames = FALSE)
cell_cycle_genes <- as.character(read.table("/Users/kerriganblake/Desktop/Misc/R_Markdown_Bootcamp_2018/regev_lab_cell_cycle_genes.txt", header=F)$V1)
cell_cycle_genes <- as.character(read.table("c:/MCSBBootcampDry/Zoo/R/regev_lab_cell_cycle_genes.txt"))
View(cell_metadata)
View(cell_metadata)
View(expression_matrix)
dim(expression_matrix)
head(cell_metadata)
matrix_subset_of_interest <- as.matrix(t(expression_matrix[which(rownames(expression_matrix) %in% cell_cycle_genes),rownames(cell_metadata)]))
matrix_subset_of_interest <- as.matrix(t(expression_matrix[which(rownames(expression_matrix) %in% cell_cycle_genes),rownames(cell_metadata)]))
matrix_subset_of_interest
matrix_subset_of_interest <- matrix_subset_of_interest[,names(colSums(matrix_subset_of_interest > 0)[colSums(matrix_subset_of_interest > 0) >= 500])]
matrix_subset_of_interest
#simple count for number of occurances of WT and Treated
table(cell_metadata$orig.ident)
#rows of the table are each condition, columns are the cluster
table(cell_metadata$orig.ident, cell_metadata$res.0.4)
#this technically sums a true/false matrix where true = 1 and false = 0
n_cells_expressed <- rowSums(expression_matrix > 0)
n_cells_expressed
#which selects values from the first vector that match values in the second vector
most_expressed <- n_cells_expressed[which(n_cells_expressed %in% max(n_cells_expressed))]
most_expressed
#to keep only the gene names, we can use names()
names_of_most_expressed <- names(most_expressed)
names_of_most_expressed
matrix_subset_of_interest <- as.matrix(t(expression_matrix[which(rownames(expression_matrix) %in% cell_cycle_genes),rownames(cell_metadata)]))
matrix_subset_of_interest
matrix_subset_of_interest <- matrix_subset_of_interest[,names(colSums(matrix_subset_of_interest > 0)[colSums(matrix_subset_of_interest > 0) >= 500])]
matrix_subset_of_interest
matrix_subset_of_interest <- as.matrix(t(expression_matrix[which(rownames(expression_matrix) %in% cell_cycle_genes),rownames(cell_metadata)]))
matrix_subset_of_interest <- matrix_subset_of_interest[,names(colSums(matrix_subset_of_interest > 0)[colSums(matrix_subset_of_interest > 0) >= 500])]
matrix_subset_of_interest
